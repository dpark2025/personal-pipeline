# ==============================================================================
# Personal Pipeline MCP Server - Build Workflow
# ==============================================================================
# Coordinates Docker and npm package builds for main branch
# Prepares artifacts for deployment and distribution

name: Build & Package

on:
  # Trigger after version management workflow completes (success check in job condition)
  workflow_run:
    workflows: ["Version Management"]
    types:
      - completed
  
  # Allow manual triggering
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild without cache'
        required: false
        default: 'false'
        type: boolean
      build_target:
        description: 'Build target'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - npm-only
          - docker-only
      push_artifacts:
        description: 'Push artifacts to registries'
        required: false
        default: 'false'
        type: boolean
      verbose:
        description: 'Enable verbose output'
        required: false
        default: 'false'
        type: boolean
  
  # Allow reusable workflow calls (for release workflow)
  workflow_call:
    inputs:
      force_rebuild:
        description: 'Force rebuild without cache'
        required: false
        default: false
        type: boolean
      build_target:
        description: 'Build target'
        required: false
        default: 'all'
        type: string
      push_artifacts:
        description: 'Push artifacts to registries'
        required: false
        default: false
        type: boolean
      verbose:
        description: 'Enable verbose output'
        required: false
        default: false
        type: boolean

# ==============================================================================
# Environment Variables
# ==============================================================================
env:
  NODE_VERSION: '20'
  IMAGE_NAME: personal-pipeline/mcp-server
  REGISTRY_GHCR: ghcr.io

# ==============================================================================
# Jobs
# ==============================================================================
jobs:
  # ==============================================================================
  # Pre-Build Check - Determine if builds are needed
  # ==============================================================================
  pre-check:
    name: Pre-Build Analysis
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_call' || github.event_name == 'workflow_dispatch' }}
    
    outputs:
      should-run-builds: ${{ steps.check.outputs.should-run-builds }}
      has-source-changes: ${{ steps.check.outputs.has-source-changes }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Check if builds are needed
        id: check
        run: |
          echo "ğŸ” Pre-analyzing changes to determine if builds are needed..."
          
          # Force builds when called from release workflow or manual dispatch with force_rebuild
          if [[ "${{ github.event_name }}" == "workflow_call" || "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "ğŸ”„ Called via ${{ github.event_name }} - builds will be executed"
            echo "has-source-changes=true" >> $GITHUB_OUTPUT
            echo "should-run-builds=true" >> $GITHUB_OUTPUT
            echo "âœ… Build workflow needed - explicit workflow call"
            exit 0
          fi
          
          # Get the commits from the version workflow that just completed
          # Look at changes since the previous version tag
          LAST_TAG=$(git describe --tags --abbrev=0 --match="v*" HEAD~1 2>/dev/null || echo "")
          if [[ -n "$LAST_TAG" ]]; then
            COMMIT_RANGE="$LAST_TAG..HEAD"
            echo "Analyzing changes since $LAST_TAG"
          else
            # If no previous tag, check last few commits
            COMMIT_RANGE="HEAD~3..HEAD"
            echo "No previous version tag found, analyzing recent commits"
          fi
          
          # Check if there are any source code changes
          SOURCE_CHANGES=$(git diff --name-only "$COMMIT_RANGE" | grep -E '^(src/|tests/|Dockerfile|package-lock\.json|tsconfig.*\.json|scripts/(build|test)-.*\.sh|\.eslintrc\.)' || echo "")
          VERSION_ONLY_CHANGES=$(git diff --name-only "$COMMIT_RANGE" | grep -E '^(package\.json|CHANGELOG\.md)$' || echo "")
          
          echo "Source changes detected:"
          if [[ -n "$SOURCE_CHANGES" ]]; then
            echo "$SOURCE_CHANGES"
            echo "has-source-changes=true" >> $GITHUB_OUTPUT
            echo "should-run-builds=true" >> $GITHUB_OUTPUT
            echo "âœ… Build workflow needed - source code changes detected"
          else
            echo "None - only version files changed"
            echo "has-source-changes=false" >> $GITHUB_OUTPUT
            echo "should-run-builds=false" >> $GITHUB_OUTPUT  
            echo "â­ï¸  Build workflow not needed - only version changes detected"
          fi
          
          if [[ -n "$VERSION_ONLY_CHANGES" ]]; then
            echo ""
            echo "Version-only changes:"
            echo "$VERSION_ONLY_CHANGES"
          fi

  # ==============================================================================
  # Build Preparation
  # ==============================================================================
  prepare:
    name: Build Preparation
    runs-on: ubuntu-latest
    needs: pre-check
    # Only run if builds are actually needed
    if: ${{ needs.pre-check.outputs.should-run-builds == 'true' }}
    
    outputs:
      version: ${{ steps.version.outputs.version }}
      build-id: ${{ steps.build-id.outputs.build-id }}
      cache-key: ${{ steps.cache-key.outputs.cache-key }}
      should-build-npm: ${{ steps.build-analysis.outputs.should-build-npm }}
      should-build-docker: ${{ steps.build-analysis.outputs.should-build-docker }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Generate build ID
        id: build-id
        run: |
          BUILD_ID="build-$(date +%Y%m%d)-$(git rev-parse --short HEAD)"
          echo "build-id=$BUILD_ID" >> $GITHUB_OUTPUT
          echo "Generated build ID: $BUILD_ID"
      
      - name: Extract version
        id: version
        run: |
          VERSION=$(node -e "console.log(JSON.parse(require('fs').readFileSync('package.json', 'utf8')).version)")
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Package version: $VERSION"
      
      - name: Generate cache key
        id: cache-key
        run: |
          CACHE_KEY="${{ runner.os }}-node-${{ env.NODE_VERSION }}-${{ hashFiles('package-lock.json') }}"
          echo "cache-key=$CACHE_KEY" >> $GITHUB_OUTPUT
      
      - name: Detect changes
        id: changes
        uses: dorny/paths-filter@v2
        with:
          filters: |
            npm:
              - 'src/**'
              - 'tests/**'
              - 'package-lock.json'
              - 'tsconfig.json'
              - 'tsconfig.*.json'
              - 'scripts/build-package.sh'
              - 'scripts/test-package.sh'
              - '.eslintrc.*'
            docker:
              - 'src/**'
              - 'Dockerfile'
              - 'package-lock.json'
              - 'docker/**'
              - 'config/*.sample.yaml'
            version-only:
              - 'package.json'
              - 'CHANGELOG.md'
      
      - name: Analyze build requirements
        id: build-analysis
        run: |
          echo "ğŸ” Analyzing build requirements..."
          
          # Check if we have only version-related changes
          NPM_CHANGES="${{ steps.changes.outputs.npm }}"
          DOCKER_CHANGES="${{ steps.changes.outputs.docker }}"
          VERSION_CHANGES="${{ steps.changes.outputs.version-only }}"
          
          # Manual overrides always build
          if [[ "${{ github.event.inputs.build_target }}" == "all" || "${{ github.event.inputs.build_target }}" == "npm-only" ]]; then
            echo "should-build-npm=true" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ npm build: Required (manual override)"
          elif [[ "$NPM_CHANGES" == "true" ]]; then
            echo "should-build-npm=true" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ npm build: Required (source changes)"
          else
            echo "should-build-npm=false" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ npm build: Skipped (no source changes)"
          fi
          
          if [[ "${{ github.event.inputs.build_target }}" == "all" || "${{ github.event.inputs.build_target }}" == "docker-only" ]]; then
            echo "should-build-docker=true" >> $GITHUB_OUTPUT
            echo "ğŸ³ Docker build: Required (manual override)"
          elif [[ "$DOCKER_CHANGES" == "true" ]]; then
            echo "should-build-docker=true" >> $GITHUB_OUTPUT
            echo "ğŸ³ Docker build: Required (source changes)"
          else
            echo "should-build-docker=false" >> $GITHUB_OUTPUT
            echo "ğŸ³ Docker build: Skipped (no source changes)"
          fi
          
          # Log version-only changes
          if [[ "$VERSION_CHANGES" == "true" ]]; then
            echo "ğŸ“‹ Version-only changes detected (package.json, CHANGELOG.md)"
          fi
      
      - name: Build summary
        run: |
          echo "ğŸš€ Build Preparation Summary"
          echo "============================"
          echo "ğŸ“ Version: ${{ steps.version.outputs.version }}"
          echo "ğŸ†” Build ID: ${{ steps.build-id.outputs.build-id }}"
          echo "ğŸ“¦ Build npm: ${{ steps.build-analysis.outputs.should-build-npm }}"
          echo "ğŸ³ Build Docker: ${{ steps.build-analysis.outputs.should-build-docker }}"
          echo "ğŸ”„ Force rebuild: ${{ github.event.inputs.force_rebuild }}"
          echo "ğŸ“‹ Version changes: ${{ steps.changes.outputs.version-only }}"

  # ==============================================================================
  # npm Package Build
  # ==============================================================================
  npm-build:
    name: npm Package Build
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.should-build-npm == 'true' || github.event.inputs.build_target == 'all' || github.event.inputs.build_target == 'npm-only'
    
    outputs:
      package-size: ${{ steps.build.outputs.package-size }}
      build-time: ${{ steps.build.outputs.build-time }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          registry-url: 'https://registry.npmjs.org'
      
      - name: Cache dependencies
        uses: actions/cache@v4
        if: github.event.inputs.force_rebuild != 'true'
        with:
          path: node_modules
          key: ${{ needs.prepare.outputs.cache-key }}
          restore-keys: |
            ${{ runner.os }}-node-${{ env.NODE_VERSION }}-
      
      - name: Install dependencies
        run: |
          echo "ğŸ“¥ Installing dependencies..."
          npm ci --silent
      
      - name: Pre-build validation
        run: |
          set -e  # Exit immediately on any error
          echo "ğŸ” Pre-build validation..."
          npm run lint -- --quiet
          npm run typecheck
          npm run test:ci
      
      - name: Build package
        id: build
        run: |
          echo "ğŸ“¦ Building npm package..."
          START_TIME=$(date +%s)
          
          # Build with production settings
          npm run build
          
          END_TIME=$(date +%s)
          BUILD_TIME=$((END_TIME - START_TIME))
          
          # Calculate package size
          PACKAGE_SIZE=$(du -sh dist/ | cut -f1)
          
          echo "package-size=$PACKAGE_SIZE" >> $GITHUB_OUTPUT
          echo "build-time=${BUILD_TIME}s" >> $GITHUB_OUTPUT
          
          echo "âœ… Package build completed in ${BUILD_TIME}s"
          echo "ğŸ“Š Package size: $PACKAGE_SIZE"
      
      - name: Validate package
        env:
          REGISTRY_URL: 'localhost:4873'
        run: |
          set +e  # Don't exit immediately on error
          set -x  # Enable bash debugging (shows each command before execution)
          echo "ğŸ§ª Validating package..."
          echo "ğŸ“‹ Starting package validation with full test suite..."
          
          bash -x scripts/test-package.sh --full
          EXIT_CODE=$?
          
          echo "ğŸ“‹ Package validation completed with exit code: $EXIT_CODE"
          
          if [ $EXIT_CODE -ne 0 ]; then
            echo "âŒ Package validation failed, gathering debug information..."
            echo "ğŸ“‹ Checking if test environment was set up..."
            ls -la .package-test/ || echo "No .package-test directory found"
            echo "ğŸ“‹ Checking for any running processes..."
            ps aux | grep -E "(verdaccio|npm)" || echo "No verdaccio/npm processes found"
            echo "ğŸ“‹ Checking for relevant log files..."
            find . -name "*.log" -not -path "./node_modules/*" -exec echo "Found log: {}" \; -exec head -20 {} \; || echo "No relevant log files found"
            echo "ğŸ“‹ Checking npm configuration..."
            npm config list || echo "Failed to list npm config"
            echo "ğŸ“‹ Checking environment variables..."
            env | grep -E "(npm|NODE|REGISTRY)" || echo "No relevant environment variables found"
          else
            echo "âœ… Package validation passed"
          fi
          
          exit $EXIT_CODE
      
      - name: Generate package metadata
        run: |
          echo "ğŸ“‹ Generating package metadata..."
          cat > package-metadata.json << EOF
          {
            "version": "${{ needs.prepare.outputs.version }}",
            "buildId": "${{ needs.prepare.outputs.build-id }}",
            "buildTime": "${{ steps.build.outputs.build-time }}",
            "packageSize": "${{ steps.build.outputs.package-size }}",
            "nodeVersion": "${{ env.NODE_VERSION }}",
            "commitSha": "${{ github.sha }}",
            "buildDate": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "registry": "npm"
          }
          EOF
      
      - name: Upload npm package artifacts
        uses: actions/upload-artifact@v4
        with:
          name: npm-package-${{ needs.prepare.outputs.build-id }}
          path: |
            dist/
            lib/
            bin/
            package.json
            package-metadata.json
            BUILD_SUMMARY.md
          retention-days: 30
      
      - name: Upload package for registry
        if: false  # Disabled - skip registry upload for now
        uses: actions/upload-artifact@v4
        with:
          name: npm-package-registry-ready
          path: |
            dist/
            lib/
            bin/
            package.json
          retention-days: 7

  # ==============================================================================
  # Docker Build
  # ==============================================================================
  docker-build:
    name: Docker Multi-Architecture Build
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.should-build-docker == 'true' || github.event.inputs.build_target == 'all' || github.event.inputs.build_target == 'docker-only'
    continue-on-error: true  # Don't cancel workflow if one architecture fails
    
    strategy:
      fail-fast: false  # Allow other architectures to continue if one fails
      matrix:
        platform:
          - linux/amd64
          - linux/arm64
    
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-size: ${{ steps.build.outputs.size }}
      
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: ${{ matrix.platform }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: ${{ matrix.platform }}
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_GHCR }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: |
            ${{ env.IMAGE_NAME }}
            ${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=raw,value=latest
            type=raw,value=${{ needs.prepare.outputs.version }}
            type=raw,value=${{ needs.prepare.outputs.build-id }}
          labels: |
            org.opencontainers.image.title=Personal Pipeline MCP Server
            org.opencontainers.image.description=Intelligent MCP server for documentation retrieval and incident response
            org.opencontainers.image.vendor=Personal Pipeline Team
            org.opencontainers.image.version=${{ needs.prepare.outputs.version }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.licenses=MIT
            build.id=${{ needs.prepare.outputs.build-id }}
            build.platform=${{ matrix.platform }}
      
      - name: Build Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: ${{ matrix.platform }}
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=${{ matrix.platform }}
          cache-to: type=gha,mode=max,scope=${{ matrix.platform }}
          outputs: type=docker,dest=/tmp/image-${{ strategy.job-index }}.tar
          build-args: |
            BUILDTIME=${{ fromJSON(steps.meta.outputs.json).labels['org.opencontainers.image.created'] }}
            VERSION=${{ needs.prepare.outputs.version }}
            REVISION=${{ github.sha }}
            BUILD_ID=${{ needs.prepare.outputs.build-id }}
      
      - name: Test Docker image
        run: |
          echo "ğŸ§ª Testing Docker image..."
          docker load --input /tmp/image-${{ strategy.job-index }}.tar
          
          # Get the first tag for testing
          IMAGE_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n1)
          echo "Testing image: $IMAGE_TAG"
          
          # Start container for testing (use memory-only cache for CI)
          docker run --name test-container -d -p 3000:3000 \
            -e NODE_ENV=production \
            -e LOG_LEVEL=warn \
            "$IMAGE_TAG"
          
          # Wait for container to start
          sleep 15
          
          # Test health endpoint (allow for Redis connection failures in CI)
          HEALTH_RESPONSE=$(curl -s --max-time 30 http://localhost:3000/health || echo "")
          if echo "$HEALTH_RESPONSE" | grep -q '"status"'; then
            echo "âœ… Docker container health check passed"
          else
            echo "âŒ Docker container health check failed"
            echo "Health response: $HEALTH_RESPONSE"
            docker logs test-container
            exit 1
          fi
          
          # Test API endpoints (allow for Redis connection failures in CI)
          API_RESPONSE=$(curl -s --max-time 10 http://localhost:3000/api/health || echo "")
          if echo "$API_RESPONSE" | grep -q '"status"'; then
            echo "âœ… API health check passed"
          else
            echo "âš ï¸ API health check failed (expected without Redis): $API_RESPONSE"
          fi
          
          # Cleanup
          docker stop test-container
          docker rm test-container
      
      - name: Security scan
        uses: aquasecurity/trivy-action@master
        with:
          input: /tmp/image-${{ strategy.job-index }}.tar
          format: 'json'
          output: 'scan-results-${{ strategy.job-index }}.json'
          severity: 'CRITICAL,HIGH'
      
      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ env.PLATFORM_SAFE }}-${{ needs.prepare.outputs.build-id }}
          path: |
            /tmp/image-${{ strategy.job-index }}.tar
            scan-results-${{ strategy.job-index }}.json
          retention-days: 7
        env:
          PLATFORM_SAFE: ${{ matrix.platform == 'linux/amd64' && 'linux-amd64' || (matrix.platform == 'linux/arm64' && 'linux-arm64' || matrix.platform) }}

  # ==============================================================================
  # Multi-Architecture Docker Manifest
  # ==============================================================================
  docker-manifest:
    name: Docker Multi-Arch Manifest
    runs-on: ubuntu-latest
    needs: [prepare, docker-build]
    if: contains(needs.docker-build.result, 'success') || needs.docker-build.result == 'failure'  # Run if at least one architecture built
    continue-on-error: true  # Don't fail entire workflow if manifest creation fails
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          platforms: linux/amd64,linux/arm64
      
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_GHCR }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Create multi-architecture manifest
        run: |
          echo "ğŸ”— Creating multi-architecture manifest..."
          
          # Check which platforms have cache available (indicating successful build)
          AVAILABLE_PLATFORMS=""
          
          if docker buildx imagetools inspect --raw type=gha,scope=linux/amd64 >/dev/null 2>&1; then
            AVAILABLE_PLATFORMS="linux/amd64"
            echo "âœ… AMD64 build cache found"
          else
            echo "âš ï¸  AMD64 build cache not found, excluding from manifest"
          fi
          
          if docker buildx imagetools inspect --raw type=gha,scope=linux/arm64 >/dev/null 2>&1; then
            if [ -n "$AVAILABLE_PLATFORMS" ]; then
              AVAILABLE_PLATFORMS="$AVAILABLE_PLATFORMS,linux/arm64"
            else
              AVAILABLE_PLATFORMS="linux/arm64"
            fi
            echo "âœ… ARM64 build cache found"
          else
            echo "âš ï¸  ARM64 build cache not found, excluding from manifest"
          fi
          
          if [ -z "$AVAILABLE_PLATFORMS" ]; then
            echo "âŒ No successful builds found, skipping manifest creation"
            exit 1
          fi
          
          echo "ğŸ“‹ Building for platforms: $AVAILABLE_PLATFORMS"
          
          # Build and push with available platforms only
          docker buildx build \
            --platform "$AVAILABLE_PLATFORMS" \
            --tag ${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.version }} \
            --tag ${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.build-id }} \
            --tag ${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}:latest \
            --label "org.opencontainers.image.version=${{ needs.prepare.outputs.version }}" \
            --label "build.id=${{ needs.prepare.outputs.build-id }}" \
            --cache-from type=gha \
            --push .
          
          echo "âœ… Multi-architecture image pushed successfully with platforms: $AVAILABLE_PLATFORMS"

  # ==============================================================================
  # Quality Gates
  # ==============================================================================
  quality-gates:
    name: Build Quality Gates
    runs-on: ubuntu-latest
    needs: [prepare, npm-build, docker-build]
    
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: npm-package-${{ needs.prepare.outputs.build-id }}
          path: ./artifacts/npm/
      
      - name: Analyze build quality
        run: |
          echo "ğŸ“Š Build Quality Analysis"
          echo "========================"
          
          # Check build results
          NPM_RESULT="${{ needs.npm-build.result }}"
          DOCKER_RESULT="${{ needs.docker-build.result }}"
          
          echo "ğŸ“¦ npm Build: $NPM_RESULT"
          echo "ğŸ³ Docker Build: $DOCKER_RESULT"
          
          # Analyze package metadata
          if [[ -f "./artifacts/npm/package-metadata.json" ]]; then
            echo ""
            echo "ğŸ“‹ Package Metadata:"
            cat ./artifacts/npm/package-metadata.json | jq .
          fi
          
          # Check for build failures
          FAILED_BUILDS=()
          [[ "$NPM_RESULT" == "failure" ]] && FAILED_BUILDS+=("npm")
          [[ "$DOCKER_RESULT" == "failure" ]] && FAILED_BUILDS+=("Docker")
          
          if [[ ${#FAILED_BUILDS[@]} -gt 0 ]]; then
            echo ""
            echo "âŒ Build failures detected:"
            for build in "${FAILED_BUILDS[@]}"; do
              echo "   - $build build failed"
            done
            exit 1
          else
            echo ""
            echo "âœ… All builds completed successfully!"
          fi
      
      - name: Generate build report
        run: |
          cat > BUILD_REPORT.md << EOF
          # Build Report
          
          **Build ID:** ${{ needs.prepare.outputs.build-id }}
          **Version:** ${{ needs.prepare.outputs.version }}
          **Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          **Commit:** ${{ github.sha }}
          
          ## Build Results
          
          | Component | Status | Details |
          |-----------|--------|---------|
          | npm Package | ${{ needs.npm-build.result == 'success' && 'âœ… Success' || 'âŒ Failed' }} | Size: ${{ needs.npm-build.outputs.package-size }}, Time: ${{ needs.npm-build.outputs.build-time }} |
          | Docker Image | ${{ contains(needs.docker-build.result, 'success') && 'âš ï¸ Partial Success' || (needs.docker-build.result == 'success' && 'âœ… Success' || 'âŒ Failed') }} | Multi-arch build attempted (some platforms may have failed) |
          | Docker Manifest | ${{ needs.docker-manifest.result == 'success' && 'âœ… Success' || (needs.docker-manifest.result == 'failure' && 'âŒ Failed' || 'â­ï¸ Skipped') }} | Combined available architectures |
          
          ## Artifacts
          
          ### npm Package
          - **Registry Ready:** âœ… Available for publishing
          - **Size:** ${{ needs.npm-build.outputs.package-size }}
          - **Build Time:** ${{ needs.npm-build.outputs.build-time }}
          
          ### Docker Images
          - **GHCR:** \`${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.version }}\`
          - **GHCR Latest:** \`${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}:latest\`
          - **Platforms:** linux/amd64, linux/arm64
          
          ## Next Steps
          
          1. **Manual Testing:** Test artifacts in staging environment
          2. **Security Review:** Review security scan results
          3. **Release Preparation:** Create release when ready
          4. **Publishing:** Publish to production registries
          
          ---
          *Generated by GitHub Actions on $(date -u +"%Y-%m-%d %H:%M:%S UTC")*
          EOF
      
      - name: Upload build report
        uses: actions/upload-artifact@v4
        with:
          name: build-report-${{ needs.prepare.outputs.build-id }}
          path: BUILD_REPORT.md
          retention-days: 90

  # ==============================================================================
  # Build Summary (runs regardless of whether builds were needed)
  # ==============================================================================
  build-summary:
    name: Build Summary
    runs-on: ubuntu-latest  
    needs: [pre-check, prepare, npm-build, docker-build, docker-manifest, quality-gates]
    if: always()
    
    steps:
      - name: Generate build summary
        run: |
          echo "ğŸ“‹ Build & Package Workflow Summary"
          echo "====================================="
          
          if [[ "${{ needs.pre-check.outputs.should-run-builds }}" == "false" ]]; then
            echo "â­ï¸  **Builds Skipped** - Only version files changed"
            echo ""
            echo "ğŸ“‹ Changes detected:"
            echo "   â€¢ Version files only (package.json, CHANGELOG.md)"
            echo "   â€¢ No source code changes requiring rebuilds"
            echo ""
            echo "âœ… **Workflow completed efficiently** - No builds needed!"
            echo ""
            echo "ğŸ’¡ Builds will run automatically when:"
            echo "   â€¢ Source code changes (src/**, tests/**)"  
            echo "   â€¢ Build configuration changes (Dockerfile, tsconfig.json)"
            echo "   â€¢ Manual override with build_target parameter"
          else
            echo "ğŸš€ **Build Results Summary**"
            echo ""
            echo "ğŸ“¦ npm Build: ${{ needs.npm-build.result || 'skipped' }}"
            echo "ğŸ³ Docker Build: ${{ needs.docker-build.result || 'skipped' }}"
            echo "ğŸ“‹ Quality Gates: ${{ needs.quality-gates.result || 'skipped' }}"
            
            if [[ "${{ needs.quality-gates.result }}" == "success" ]]; then
              echo ""
              echo "âœ… **All builds completed successfully!**"
              echo "ğŸ¯ Artifacts are ready for deployment"
            else  
              echo ""
              echo "âŒ **Some builds failed** - Check workflow details"
            fi
          fi
          
          echo ""
          echo "ğŸ”— **Workflow Details:**"
          echo "   â€¢ Pre-check: ${{ needs.pre-check.result }}"
          echo "   â€¢ Should run builds: ${{ needs.pre-check.outputs.should-run-builds }}"
          echo "   â€¢ Has source changes: ${{ needs.pre-check.outputs.has-source-changes }}"

  # ==============================================================================
  # Notification (only runs when builds actually executed)
  # ==============================================================================
  notify:
    name: Build Notification
    runs-on: ubuntu-latest
    needs: [pre-check, prepare, npm-build, docker-build, docker-manifest, quality-gates]
    if: ${{ needs.pre-check.outputs.should-run-builds == 'true' && always() }}
    
    steps:
      - name: Determine build status
        id: status
        run: |
          NPM_STATUS="${{ needs.npm-build.result }}"
          DOCKER_STATUS="${{ needs.docker-build.result }}"
          MANIFEST_STATUS="${{ needs.docker-manifest.result }}"
          QUALITY_STATUS="${{ needs.quality-gates.result }}"
          
          # Check for actual failures (skipped jobs don't count as failures)
          if [[ "$NPM_STATUS" == "failure" || "$DOCKER_STATUS" == "failure" || "$MANIFEST_STATUS" == "failure" || "$QUALITY_STATUS" == "failure" ]]; then
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "message=Some builds failed. Check the workflow for details." >> $GITHUB_OUTPUT
          else
            echo "status=success" >> $GITHUB_OUTPUT
            echo "message=All enabled builds completed successfully!" >> $GITHUB_OUTPUT
          fi
      
      - name: Build notification
        run: |
          echo "ğŸš€ Build Notification"
          echo "===================="
          echo "ğŸ“ Version: ${{ needs.prepare.outputs.version }}"
          echo "ğŸ†” Build ID: ${{ needs.prepare.outputs.build-id }}"
          echo "ğŸ“Š Status: ${{ steps.status.outputs.status }}"
          echo "ğŸ’¬ Message: ${{ steps.status.outputs.message }}"
          echo ""
          
          if [[ "${{ steps.status.outputs.status }}" == "success" ]]; then
            echo "âœ… Build artifacts are ready for deployment!"
            echo ""
            echo "ğŸ“¦ npm Package:"
            echo "   - Available in artifacts as 'npm-package-registry-ready'"
            echo "   - Ready for publishing to npm registry"
            echo ""
            echo "ğŸ³ Docker Images:"
            echo "   - Multi-architecture build completed"
            echo "   - Available at: ${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}:${{ needs.prepare.outputs.version }}"
            echo "   - Latest tag: ${{ env.REGISTRY_GHCR }}/${{ env.IMAGE_NAME }}:latest"
          else
            echo "âŒ Build failed. Please check the workflow logs for details."
            exit 1
          fi

# ==============================================================================
# Workflow Summary
# ==============================================================================
# This build workflow coordinates npm package and Docker builds:
#
# 1. Preparation:
#    - Generates build ID and extracts version
#    - Detects what needs to be built based on changes
#    - Supports manual override with workflow_dispatch
#
# 2. npm Package Build:
#    - Full production build with validation
#    - Package testing and size analysis
#    - Artifact preparation for registry publishing
#
# 3. Docker Build:
#    - Multi-architecture builds (amd64, arm64)
#    - Security scanning with Trivy
#    - Container testing and validation
#    - Multi-arch manifest creation
#
# 4. Quality Gates:
#    - Build result analysis
#    - Artifact validation
#    - Build report generation
#
# 5. Notification:
#    - Status summary and next steps
#    - Artifact availability information
#
# Artifacts are prepared but not automatically published,
# allowing for manual review and controlled releases.